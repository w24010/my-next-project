{"version":3,"sources":["../../node_modules/retry/lib/retry_operation.js","../../node_modules/retry/lib/retry.js","../../node_modules/retry/index.js","../../node_modules/async-retry/lib/index.js","../../src/index.ts","../../src/createClient.ts","../../src/lib/fetch.ts","../../src/utils/constants.ts","../../src/utils/isCheckValue.ts","../../src/utils/parseQuery.ts","../../src/createManagementClient.ts"],"names":["require_retry_operation","__commonJSMin","exports","module","RetryOperation","timeouts","options","err","currentTime","timeout","self","fn","timeoutOps","counts","mainError","mainErrorCount","i","error","message","count","require_retry","opts","key","b","attempt","random","obj","methods","method","original","op","args","callback","require_lib","retrier","retry","run","resolve","reject","bail","onError","num","runAttempt","val","src_exports","__export","createClient","createManagementClient","import_async_retry","generateFetchClient","apiKey","req","init","headers","BASE_DOMAIN","BASE_MANAGEMENT_DOMAIN","API_VERSION_1","isObject","value","isString","parseQuery","queries","acc","serviceDomain","retryOption","baseUrl","makeRequest","endpoint","contentId","requestInit","fetchClient","queryString","url","getMessageFromResponse","response","customRequestInit","alternateField","draftKey","filters","orders","defaultQueries","totalCount","contentIds","offset","sleep","ms","isStringArray","arr","item","contents","ids","content","_contents","isDraft","path","apiVersion","data","name","type","customRequestHeaders","formData","chunks","reader","chunk","blob","nameFromURL"],"mappings":"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","sourcesContent":["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","module.exports = require('./lib/retry');","// Packages\nvar retrier = require('retry');\n\nfunction retry(fn, opts) {\n  function run(resolve, reject) {\n    var options = opts || {};\n    var op;\n\n    // Default `randomize` to true\n    if (!('randomize' in options)) {\n      options.randomize = true;\n    }\n\n    op = retrier.operation(options);\n\n    // We allow the user to abort retrying\n    // this makes sense in the cases where\n    // knowledge is obtained that retrying\n    // would be futile (e.g.: auth errors)\n\n    function bail(err) {\n      reject(err || new Error('Aborted'));\n    }\n\n    function onError(err, num) {\n      if (err.bail) {\n        bail(err);\n        return;\n      }\n\n      if (!op.retry(err)) {\n        reject(op.mainError());\n      } else if (options.onRetry) {\n        options.onRetry(err, num);\n      }\n    }\n\n    function runAttempt(num) {\n      var val;\n\n      try {\n        val = fn(bail, num);\n      } catch (err) {\n        onError(err, num);\n        return;\n      }\n\n      Promise.resolve(val)\n        .then(resolve)\n        .catch(function catchIt(err) {\n          onError(err, num);\n        });\n    }\n\n    op.attempt(runAttempt);\n  }\n\n  return new Promise(run);\n}\n\nmodule.exports = retry;\n","export { createClient } from './createClient';\nexport { createManagementClient } from './createManagementClient';\nexport * from './types';\n","/**\n * microCMS API SDK\n * https://github.com/microcmsio/microcms-js-sdk\n */\nimport retry from 'async-retry';\nimport { generateFetchClient } from './lib/fetch';\nimport {\n  CreateRequest,\n  DeleteRequest,\n  GetAllContentIdsRequest,\n  GetAllContentRequest,\n  GetListDetailRequest,\n  GetListRequest,\n  GetObjectRequest,\n  GetRequest,\n  MakeRequest,\n  MicroCMSClient,\n  MicroCMSListContent,\n  MicroCMSListResponse,\n  MicroCMSObjectContent,\n  MicroCMSQueries,\n  UpdateRequest,\n  WriteApiRequestResult,\n} from './types';\nimport {\n  API_VERSION_1,\n  BASE_DOMAIN,\n  MAX_RETRY_COUNT,\n  MIN_TIMEOUT_MS,\n} from './utils/constants';\nimport { isString } from './utils/isCheckValue';\nimport { parseQuery } from './utils/parseQuery';\n\n/**\n * Initialize SDK Client\n */\nexport const createClient = ({\n  serviceDomain,\n  apiKey,\n  retry: retryOption,\n}: MicroCMSClient) => {\n  if (!serviceDomain || !apiKey) {\n    throw new Error('parameter is required (check serviceDomain and apiKey)');\n  }\n\n  if (!isString(serviceDomain) || !isString(apiKey)) {\n    throw new Error('parameter is not string');\n  }\n\n  /**\n   * Defined microCMS base URL\n   */\n  const baseUrl = `https://${serviceDomain}.${BASE_DOMAIN}/api/${API_VERSION_1}`;\n\n  /**\n   * Make request\n   */\n  const makeRequest = async ({\n    endpoint,\n    contentId,\n    queries = {},\n    requestInit,\n  }: MakeRequest) => {\n    const fetchClient = generateFetchClient(apiKey);\n    const queryString = parseQuery(queries);\n    const url = `${baseUrl}/${endpoint}${contentId ? `/${contentId}` : ''}${\n      queryString ? `?${queryString}` : ''\n    }`;\n\n    const getMessageFromResponse = async (response: Response) => {\n      // Enclose `response.json()` in a try since it may throw an error\n      // Only return the `message` if there is a `message`\n      try {\n        const { message } = await response.json();\n        return message ?? null;\n      } catch (_) {\n        return null;\n      }\n    };\n\n    return await retry(\n      async (bail) => {\n        let response;\n        try {\n          response = await fetchClient(url, {\n            ...requestInit,\n            method: requestInit?.method ?? 'GET',\n          });\n\n          // If a status code in the 400 range other than 429 is returned, do not retry.\n          if (\n            response.status !== 429 &&\n            response.status >= 400 &&\n            response.status < 500\n          ) {\n            const message = await getMessageFromResponse(response);\n\n            return bail(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          // If the response fails with any other status code, retry until the set number of attempts is reached.\n          if (!response.ok) {\n            const message = await getMessageFromResponse(response);\n\n            return Promise.reject(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          if (requestInit?.method === 'DELETE') return;\n\n          return response.json();\n        } catch (error) {\n          if (error.data) {\n            throw error.data;\n          }\n\n          if (error.response?.data) {\n            throw error.response.data;\n          }\n\n          return Promise.reject(\n            new Error(`Network Error.\\n  Details: ${error.message ?? ''}`),\n          );\n        }\n      },\n      {\n        retries: retryOption ? MAX_RETRY_COUNT : 0,\n        onRetry: (err, num) => {\n          console.log(err);\n          console.log(`Waiting for retry (${num}/${MAX_RETRY_COUNT})`);\n        },\n        minTimeout: MIN_TIMEOUT_MS,\n      },\n    );\n  };\n\n  /**\n   * Get list and object API data for microCMS\n   */\n  const get = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetRequest): Promise<T> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API data for microCMS\n   */\n  const getList = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetListRequest): Promise<MicroCMSListResponse<T>> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API detail data for microCMS\n   */\n  const getListDetail = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetListDetailRequest): Promise<T & MicroCMSListContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get object API data for microCMS\n   */\n  const getObject = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetObjectRequest): Promise<T & MicroCMSObjectContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  const getAllContentIds = async ({\n    endpoint,\n    alternateField,\n    draftKey,\n    filters,\n    orders,\n    customRequestInit,\n  }: GetAllContentIdsRequest): Promise<string[]> => {\n    const limit = 100;\n    const defaultQueries: MicroCMSQueries = {\n      draftKey,\n      filters,\n      orders,\n      limit,\n      fields: alternateField ?? 'id',\n      depth: 0,\n    };\n\n    const { totalCount } = await makeRequest({\n      endpoint,\n      queries: { ...defaultQueries, limit: 0 },\n      requestInit: customRequestInit,\n    });\n\n    let contentIds: string[] = [];\n    let offset = 0;\n\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n    const isStringArray = (arr: unknown[]): arr is string[] =>\n      arr.every((item) => typeof item === 'string');\n\n    while (contentIds.length < totalCount) {\n      const { contents } = (await makeRequest({\n        endpoint,\n        queries: { ...defaultQueries, offset },\n        requestInit: customRequestInit,\n      })) as MicroCMSListResponse<Record<string, unknown>>;\n\n      const ids = contents.map((content) => content[alternateField ?? 'id']);\n\n      if (!isStringArray(ids)) {\n        throw new Error(\n          'The value of the field specified by `alternateField` is not a string.',\n        );\n      }\n\n      contentIds = [...contentIds, ...ids];\n\n      offset += limit;\n      if (contentIds.length < totalCount) {\n        await sleep(1000); // sleep for 1 second before the next request\n      }\n    }\n\n    return contentIds;\n  };\n\n  /**\n   * Get all content API data for microCMS\n   */\n  const getAllContents = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetAllContentRequest): Promise<(T & MicroCMSListContent)[]> => {\n    const limit = 100;\n\n    const { totalCount } = await makeRequest({\n      endpoint,\n      queries: { ...queries, limit: 0 },\n      requestInit: customRequestInit,\n    });\n\n    let contents: (T & MicroCMSListContent)[] = [];\n    let offset = 0;\n\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n\n    while (contents.length < totalCount) {\n      const { contents: _contents } = (await makeRequest({\n        endpoint,\n        queries: { ...queries, limit, offset },\n        requestInit: customRequestInit,\n      })) as MicroCMSListResponse<T>;\n\n      contents = contents.concat(_contents);\n\n      offset += limit;\n      if (contents.length < totalCount) {\n        await sleep(1000); // sleep for 1 second before the next request\n      }\n    }\n\n    return contents;\n  };\n\n  /**\n   * Create new content in the microCMS list API data\n   */\n  const create = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    isDraft = false,\n    customRequestInit,\n  }: CreateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const queries: MakeRequest['queries'] = isDraft ? { status: 'draft' } : {};\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: contentId ? 'PUT' : 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit,\n    });\n  };\n\n  /**\n   * Update content in their microCMS list and object API data\n   */\n  const update = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    customRequestInit,\n  }: UpdateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      requestInit,\n    });\n  };\n\n  /**\n   * Delete content in their microCMS list and object API data\n   */\n  const _delete = async ({\n    endpoint,\n    contentId,\n    customRequestInit,\n  }: DeleteRequest): Promise<void> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    if (!contentId) {\n      return Promise.reject(new Error('contentId is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'DELETE',\n      headers: {},\n      body: undefined,\n    };\n\n    await makeRequest({ endpoint, contentId, requestInit });\n  };\n\n  return {\n    get,\n    getList,\n    getListDetail,\n    getObject,\n    getAllContentIds,\n    getAllContents,\n    create,\n    update,\n    delete: _delete,\n  };\n};\n","import { Fetch } from 'src/types';\n\nexport const generateFetchClient = (apiKey: string): Fetch => {\n  return async (req, init) => {\n    const headers = new Headers(init?.headers);\n\n    if (!headers.has('X-MICROCMS-API-KEY')) {\n      headers.set('X-MICROCMS-API-KEY', apiKey);\n    }\n\n    return fetch(req, { ...init, headers });\n  };\n};\n","export const BASE_DOMAIN = 'microcms.io';\nexport const BASE_MANAGEMENT_DOMAIN = 'microcms-management.io';\nexport const API_VERSION_1 = 'v1';\nexport const API_VERSION_2 = 'v2';\nexport const MAX_RETRY_COUNT = 2;\nexport const MIN_TIMEOUT_MS = 5000;\n","/**\n * Check object\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object';\n};\n\n/**\n * Check string\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string';\n};\n","/**\n * Parse query.\n *\n * @param {object} queries\n * @return {string} queryString\n */\nimport { MicroCMSQueries } from '../types';\nimport { isObject } from './isCheckValue';\n\nexport const parseQuery = (queries: MicroCMSQueries): string => {\n  if (!isObject(queries)) {\n    throw new Error('queries is not object');\n  }\n  const queryString = new URLSearchParams(\n    Object.entries(queries).reduce(\n      (acc, [key, value]) => {\n        acc[key] = String(value);\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n  ).toString();\n\n  return queryString;\n};\n","import { generateFetchClient } from './lib/fetch';\nimport { MicroCMSManagementClient, UploadMediaRequest } from './types';\nimport {\n  API_VERSION_1,\n  API_VERSION_2,\n  BASE_MANAGEMENT_DOMAIN,\n} from './utils/constants';\nimport { isString } from './utils/isCheckValue';\nimport { parseQuery } from './utils/parseQuery';\n\ninterface MakeRequest {\n  path: string;\n  apiVersion: typeof API_VERSION_1 | typeof API_VERSION_2;\n  queries?: Record<string, unknown>;\n  requestInit?: RequestInit;\n}\n\nexport const createManagementClient = ({\n  serviceDomain,\n  apiKey,\n}: MicroCMSManagementClient) => {\n  if (!serviceDomain || !apiKey) {\n    throw new Error('parameter is required (check serviceDomain and apiKey)');\n  }\n\n  if (!isString(serviceDomain) || !isString(apiKey)) {\n    throw new Error('parameter is not string');\n  }\n\n  /**\n   * Make request\n   */\n  const makeRequest = async ({\n    path,\n    apiVersion,\n    queries = {},\n    requestInit,\n  }: MakeRequest) => {\n    /**\n     * Defined microCMS base URL\n     */\n    const baseUrl = `https://${serviceDomain}.${BASE_MANAGEMENT_DOMAIN}/api/${apiVersion}`;\n\n    const fetchClient = generateFetchClient(apiKey);\n    const queryString = parseQuery(queries);\n    const url = `${baseUrl}/${path}${queryString ? `?${queryString}` : ''}`;\n\n    const getMessageFromResponse = async (response: Response) => {\n      // Enclose `response.json()` in a try since it may throw an error\n      // Only return the `message` if there is a `message`\n      try {\n        const { message } = await response.json();\n        return message ?? null;\n      } catch (_) {\n        return null;\n      }\n    };\n\n    let response: Response;\n    try {\n      response = await fetchClient(url, {\n        ...requestInit,\n        method: requestInit?.method ?? 'GET',\n      });\n    } catch (error) {\n      if (error.data) {\n        throw error.data;\n      }\n\n      if (error.response?.data) {\n        throw error.response.data;\n      }\n\n      return Promise.reject(\n        new Error(`Network Error.\\n  Details: ${error.message ?? ''}`),\n      );\n    }\n\n    // If the response fails with any other status code, retry until the set number of attempts is reached.\n    if (!response.ok) {\n      const message = await getMessageFromResponse(response);\n\n      return Promise.reject(\n        new Error(\n          `fetch API response status: ${response.status}${\n            message ? `\\n  message is \\`${message}\\`` : ''\n          }`,\n        ),\n      );\n    }\n\n    return response.json();\n  };\n\n  const uploadMedia = async ({\n    data,\n    name,\n    type,\n    customRequestHeaders,\n  }: UploadMediaRequest): Promise<{ url: string }> => {\n    const formData = new FormData();\n\n    if (data instanceof Blob) {\n      // Node.jsではFile APIはnode:bufferからのみサポートされているため、instance of Fileでは判定せずにnameプロパティが存在するかで判定する\n      if ((data as File).name) {\n        formData.set('file', data, (data as File).name);\n      } else {\n        if (!name) {\n          throw new Error('name is required when data is a Blob');\n        }\n        formData.set('file', data, name);\n      }\n    } else if (data instanceof ReadableStream) {\n      if (!name) {\n        throw new Error('name is required when data is a ReadableStream');\n      }\n      if (!type) {\n        throw new Error('type is required when data is a ReadableStream');\n      }\n\n      const chunks = [];\n      const reader = data.getReader();\n\n      let chunk;\n      while (!(chunk = await reader.read()).done) {\n        chunks.push(chunk.value);\n      }\n\n      formData.set('file', new Blob(chunks, { type }), name);\n    } else if (typeof data === 'string' || data instanceof URL) {\n      const url = data instanceof URL ? data : new URL(data);\n      const response = await fetch(\n        url.toString(),\n        customRequestHeaders ? { headers: customRequestHeaders } : undefined,\n      );\n      const blob = await response.blob();\n      const nameFromURL = new URL(response.url).pathname.split('/').pop();\n      formData.set('file', blob, name ?? nameFromURL);\n    }\n\n    return makeRequest({\n      path: 'media',\n      apiVersion: API_VERSION_1,\n      requestInit: { method: 'POST', body: formData },\n    });\n  };\n\n  return {\n    uploadMedia,\n  };\n};\n"]}