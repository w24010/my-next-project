{"version":3,"sources":["../../src/createClient.ts","../../src/lib/fetch.ts","../../src/utils/constants.ts","../../src/utils/isCheckValue.ts","../../src/utils/parseQuery.ts","../../src/createManagementClient.ts"],"names":["retry","generateFetchClient","apiKey","req","init","headers","BASE_DOMAIN","BASE_MANAGEMENT_DOMAIN","API_VERSION_1","isObject","value","isString","parseQuery","queries","acc","key","createClient","serviceDomain","retryOption","baseUrl","makeRequest","endpoint","contentId","requestInit","fetchClient","queryString","url","getMessageFromResponse","response","message","bail","error","err","num","customRequestInit","alternateField","draftKey","filters","orders","defaultQueries","totalCount","contentIds","offset","sleep","ms","resolve","isStringArray","arr","item","contents","ids","content","_contents","isDraft","createManagementClient","path","apiVersion","data","name","type","customRequestHeaders","formData","chunks","reader","chunk","blob","nameFromURL"],"mappings":"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","sourcesContent":["/**\n * microCMS API SDK\n * https://github.com/microcmsio/microcms-js-sdk\n */\nimport retry from 'async-retry';\nimport { generateFetchClient } from './lib/fetch';\nimport {\n  CreateRequest,\n  DeleteRequest,\n  GetAllContentIdsRequest,\n  GetAllContentRequest,\n  GetListDetailRequest,\n  GetListRequest,\n  GetObjectRequest,\n  GetRequest,\n  MakeRequest,\n  MicroCMSClient,\n  MicroCMSListContent,\n  MicroCMSListResponse,\n  MicroCMSObjectContent,\n  MicroCMSQueries,\n  UpdateRequest,\n  WriteApiRequestResult,\n} from './types';\nimport {\n  API_VERSION_1,\n  BASE_DOMAIN,\n  MAX_RETRY_COUNT,\n  MIN_TIMEOUT_MS,\n} from './utils/constants';\nimport { isString } from './utils/isCheckValue';\nimport { parseQuery } from './utils/parseQuery';\n\n/**\n * Initialize SDK Client\n */\nexport const createClient = ({\n  serviceDomain,\n  apiKey,\n  retry: retryOption,\n}: MicroCMSClient) => {\n  if (!serviceDomain || !apiKey) {\n    throw new Error('parameter is required (check serviceDomain and apiKey)');\n  }\n\n  if (!isString(serviceDomain) || !isString(apiKey)) {\n    throw new Error('parameter is not string');\n  }\n\n  /**\n   * Defined microCMS base URL\n   */\n  const baseUrl = `https://${serviceDomain}.${BASE_DOMAIN}/api/${API_VERSION_1}`;\n\n  /**\n   * Make request\n   */\n  const makeRequest = async ({\n    endpoint,\n    contentId,\n    queries = {},\n    requestInit,\n  }: MakeRequest) => {\n    const fetchClient = generateFetchClient(apiKey);\n    const queryString = parseQuery(queries);\n    const url = `${baseUrl}/${endpoint}${contentId ? `/${contentId}` : ''}${\n      queryString ? `?${queryString}` : ''\n    }`;\n\n    const getMessageFromResponse = async (response: Response) => {\n      // Enclose `response.json()` in a try since it may throw an error\n      // Only return the `message` if there is a `message`\n      try {\n        const { message } = await response.json();\n        return message ?? null;\n      } catch (_) {\n        return null;\n      }\n    };\n\n    return await retry(\n      async (bail) => {\n        let response;\n        try {\n          response = await fetchClient(url, {\n            ...requestInit,\n            method: requestInit?.method ?? 'GET',\n          });\n\n          // If a status code in the 400 range other than 429 is returned, do not retry.\n          if (\n            response.status !== 429 &&\n            response.status >= 400 &&\n            response.status < 500\n          ) {\n            const message = await getMessageFromResponse(response);\n\n            return bail(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          // If the response fails with any other status code, retry until the set number of attempts is reached.\n          if (!response.ok) {\n            const message = await getMessageFromResponse(response);\n\n            return Promise.reject(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          if (requestInit?.method === 'DELETE') return;\n\n          return response.json();\n        } catch (error) {\n          if (error.data) {\n            throw error.data;\n          }\n\n          if (error.response?.data) {\n            throw error.response.data;\n          }\n\n          return Promise.reject(\n            new Error(`Network Error.\\n  Details: ${error.message ?? ''}`),\n          );\n        }\n      },\n      {\n        retries: retryOption ? MAX_RETRY_COUNT : 0,\n        onRetry: (err, num) => {\n          console.log(err);\n          console.log(`Waiting for retry (${num}/${MAX_RETRY_COUNT})`);\n        },\n        minTimeout: MIN_TIMEOUT_MS,\n      },\n    );\n  };\n\n  /**\n   * Get list and object API data for microCMS\n   */\n  const get = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetRequest): Promise<T> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API data for microCMS\n   */\n  const getList = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetListRequest): Promise<MicroCMSListResponse<T>> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API detail data for microCMS\n   */\n  const getListDetail = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetListDetailRequest): Promise<T & MicroCMSListContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get object API data for microCMS\n   */\n  const getObject = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetObjectRequest): Promise<T & MicroCMSObjectContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  const getAllContentIds = async ({\n    endpoint,\n    alternateField,\n    draftKey,\n    filters,\n    orders,\n    customRequestInit,\n  }: GetAllContentIdsRequest): Promise<string[]> => {\n    const limit = 100;\n    const defaultQueries: MicroCMSQueries = {\n      draftKey,\n      filters,\n      orders,\n      limit,\n      fields: alternateField ?? 'id',\n      depth: 0,\n    };\n\n    const { totalCount } = await makeRequest({\n      endpoint,\n      queries: { ...defaultQueries, limit: 0 },\n      requestInit: customRequestInit,\n    });\n\n    let contentIds: string[] = [];\n    let offset = 0;\n\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n    const isStringArray = (arr: unknown[]): arr is string[] =>\n      arr.every((item) => typeof item === 'string');\n\n    while (contentIds.length < totalCount) {\n      const { contents } = (await makeRequest({\n        endpoint,\n        queries: { ...defaultQueries, offset },\n        requestInit: customRequestInit,\n      })) as MicroCMSListResponse<Record<string, unknown>>;\n\n      const ids = contents.map((content) => content[alternateField ?? 'id']);\n\n      if (!isStringArray(ids)) {\n        throw new Error(\n          'The value of the field specified by `alternateField` is not a string.',\n        );\n      }\n\n      contentIds = [...contentIds, ...ids];\n\n      offset += limit;\n      if (contentIds.length < totalCount) {\n        await sleep(1000); // sleep for 1 second before the next request\n      }\n    }\n\n    return contentIds;\n  };\n\n  /**\n   * Get all content API data for microCMS\n   */\n  const getAllContents = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetAllContentRequest): Promise<(T & MicroCMSListContent)[]> => {\n    const limit = 100;\n\n    const { totalCount } = await makeRequest({\n      endpoint,\n      queries: { ...queries, limit: 0 },\n      requestInit: customRequestInit,\n    });\n\n    let contents: (T & MicroCMSListContent)[] = [];\n    let offset = 0;\n\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n\n    while (contents.length < totalCount) {\n      const { contents: _contents } = (await makeRequest({\n        endpoint,\n        queries: { ...queries, limit, offset },\n        requestInit: customRequestInit,\n      })) as MicroCMSListResponse<T>;\n\n      contents = contents.concat(_contents);\n\n      offset += limit;\n      if (contents.length < totalCount) {\n        await sleep(1000); // sleep for 1 second before the next request\n      }\n    }\n\n    return contents;\n  };\n\n  /**\n   * Create new content in the microCMS list API data\n   */\n  const create = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    isDraft = false,\n    customRequestInit,\n  }: CreateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const queries: MakeRequest['queries'] = isDraft ? { status: 'draft' } : {};\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: contentId ? 'PUT' : 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit,\n    });\n  };\n\n  /**\n   * Update content in their microCMS list and object API data\n   */\n  const update = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    customRequestInit,\n  }: UpdateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      requestInit,\n    });\n  };\n\n  /**\n   * Delete content in their microCMS list and object API data\n   */\n  const _delete = async ({\n    endpoint,\n    contentId,\n    customRequestInit,\n  }: DeleteRequest): Promise<void> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    if (!contentId) {\n      return Promise.reject(new Error('contentId is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'DELETE',\n      headers: {},\n      body: undefined,\n    };\n\n    await makeRequest({ endpoint, contentId, requestInit });\n  };\n\n  return {\n    get,\n    getList,\n    getListDetail,\n    getObject,\n    getAllContentIds,\n    getAllContents,\n    create,\n    update,\n    delete: _delete,\n  };\n};\n","import { Fetch } from 'src/types';\n\nexport const generateFetchClient = (apiKey: string): Fetch => {\n  return async (req, init) => {\n    const headers = new Headers(init?.headers);\n\n    if (!headers.has('X-MICROCMS-API-KEY')) {\n      headers.set('X-MICROCMS-API-KEY', apiKey);\n    }\n\n    return fetch(req, { ...init, headers });\n  };\n};\n","export const BASE_DOMAIN = 'microcms.io';\nexport const BASE_MANAGEMENT_DOMAIN = 'microcms-management.io';\nexport const API_VERSION_1 = 'v1';\nexport const API_VERSION_2 = 'v2';\nexport const MAX_RETRY_COUNT = 2;\nexport const MIN_TIMEOUT_MS = 5000;\n","/**\n * Check object\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object';\n};\n\n/**\n * Check string\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string';\n};\n","/**\n * Parse query.\n *\n * @param {object} queries\n * @return {string} queryString\n */\nimport { MicroCMSQueries } from '../types';\nimport { isObject } from './isCheckValue';\n\nexport const parseQuery = (queries: MicroCMSQueries): string => {\n  if (!isObject(queries)) {\n    throw new Error('queries is not object');\n  }\n  const queryString = new URLSearchParams(\n    Object.entries(queries).reduce(\n      (acc, [key, value]) => {\n        acc[key] = String(value);\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n  ).toString();\n\n  return queryString;\n};\n","import { generateFetchClient } from './lib/fetch';\nimport { MicroCMSManagementClient, UploadMediaRequest } from './types';\nimport {\n  API_VERSION_1,\n  API_VERSION_2,\n  BASE_MANAGEMENT_DOMAIN,\n} from './utils/constants';\nimport { isString } from './utils/isCheckValue';\nimport { parseQuery } from './utils/parseQuery';\n\ninterface MakeRequest {\n  path: string;\n  apiVersion: typeof API_VERSION_1 | typeof API_VERSION_2;\n  queries?: Record<string, unknown>;\n  requestInit?: RequestInit;\n}\n\nexport const createManagementClient = ({\n  serviceDomain,\n  apiKey,\n}: MicroCMSManagementClient) => {\n  if (!serviceDomain || !apiKey) {\n    throw new Error('parameter is required (check serviceDomain and apiKey)');\n  }\n\n  if (!isString(serviceDomain) || !isString(apiKey)) {\n    throw new Error('parameter is not string');\n  }\n\n  /**\n   * Make request\n   */\n  const makeRequest = async ({\n    path,\n    apiVersion,\n    queries = {},\n    requestInit,\n  }: MakeRequest) => {\n    /**\n     * Defined microCMS base URL\n     */\n    const baseUrl = `https://${serviceDomain}.${BASE_MANAGEMENT_DOMAIN}/api/${apiVersion}`;\n\n    const fetchClient = generateFetchClient(apiKey);\n    const queryString = parseQuery(queries);\n    const url = `${baseUrl}/${path}${queryString ? `?${queryString}` : ''}`;\n\n    const getMessageFromResponse = async (response: Response) => {\n      // Enclose `response.json()` in a try since it may throw an error\n      // Only return the `message` if there is a `message`\n      try {\n        const { message } = await response.json();\n        return message ?? null;\n      } catch (_) {\n        return null;\n      }\n    };\n\n    let response: Response;\n    try {\n      response = await fetchClient(url, {\n        ...requestInit,\n        method: requestInit?.method ?? 'GET',\n      });\n    } catch (error) {\n      if (error.data) {\n        throw error.data;\n      }\n\n      if (error.response?.data) {\n        throw error.response.data;\n      }\n\n      return Promise.reject(\n        new Error(`Network Error.\\n  Details: ${error.message ?? ''}`),\n      );\n    }\n\n    // If the response fails with any other status code, retry until the set number of attempts is reached.\n    if (!response.ok) {\n      const message = await getMessageFromResponse(response);\n\n      return Promise.reject(\n        new Error(\n          `fetch API response status: ${response.status}${\n            message ? `\\n  message is \\`${message}\\`` : ''\n          }`,\n        ),\n      );\n    }\n\n    return response.json();\n  };\n\n  const uploadMedia = async ({\n    data,\n    name,\n    type,\n    customRequestHeaders,\n  }: UploadMediaRequest): Promise<{ url: string }> => {\n    const formData = new FormData();\n\n    if (data instanceof Blob) {\n      // Node.jsではFile APIはnode:bufferからのみサポートされているため、instance of Fileでは判定せずにnameプロパティが存在するかで判定する\n      if ((data as File).name) {\n        formData.set('file', data, (data as File).name);\n      } else {\n        if (!name) {\n          throw new Error('name is required when data is a Blob');\n        }\n        formData.set('file', data, name);\n      }\n    } else if (data instanceof ReadableStream) {\n      if (!name) {\n        throw new Error('name is required when data is a ReadableStream');\n      }\n      if (!type) {\n        throw new Error('type is required when data is a ReadableStream');\n      }\n\n      const chunks = [];\n      const reader = data.getReader();\n\n      let chunk;\n      while (!(chunk = await reader.read()).done) {\n        chunks.push(chunk.value);\n      }\n\n      formData.set('file', new Blob(chunks, { type }), name);\n    } else if (typeof data === 'string' || data instanceof URL) {\n      const url = data instanceof URL ? data : new URL(data);\n      const response = await fetch(\n        url.toString(),\n        customRequestHeaders ? { headers: customRequestHeaders } : undefined,\n      );\n      const blob = await response.blob();\n      const nameFromURL = new URL(response.url).pathname.split('/').pop();\n      formData.set('file', blob, name ?? nameFromURL);\n    }\n\n    return makeRequest({\n      path: 'media',\n      apiVersion: API_VERSION_1,\n      requestInit: { method: 'POST', body: formData },\n    });\n  };\n\n  return {\n    uploadMedia,\n  };\n};\n"]}